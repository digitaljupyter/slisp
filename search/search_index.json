{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Salmon Lisp Salmon is a Lisp dialect focused on extensibility, portability, and speed. There's many different functions for many use cases, to learn about the standard library, please visit the standard library documentation.","title":"Salmon Lisp"},{"location":"#salmon-lisp","text":"Salmon is a Lisp dialect focused on extensibility, portability, and speed. There's many different functions for many use cases, to learn about the standard library, please visit the standard library documentation.","title":"Salmon Lisp"},{"location":"Bible/","text":"The Official Salmon Bible (all versions) This book goes over the entirety of SLisp. This is perfect for those looking to be experienced in D and SLisp, while also being useful for translating these skills over to other Lisp dialects. Note In the dictionary, a bible is defined as an authoritative book in a particular atmosphere, meaing that this book is the Holy Grail of SLisp tutorials, after reading it you'll learn everything you need to and become an SLisp professional! The book is written in LaTeX and licensed under a permissive MIT license. Viewing the Book To view it, please visit this page.","title":"Bible"},{"location":"Bible/#the-official-salmon-bible-all-versions","text":"This book goes over the entirety of SLisp. This is perfect for those looking to be experienced in D and SLisp, while also being useful for translating these skills over to other Lisp dialects. Note In the dictionary, a bible is defined as an authoritative book in a particular atmosphere, meaing that this book is the Holy Grail of SLisp tutorials, after reading it you'll learn everything you need to and become an SLisp professional! The book is written in LaTeX and licensed under a permissive MIT license.","title":"The Official Salmon Bible (all versions)"},{"location":"Bible/#viewing-the-book","text":"To view it, please visit this page.","title":"Viewing the Book"},{"location":"FAQ/","text":"Frequently Asked Questions I see this doesn't use a traditional parsing method, is it stable? This is a common question for those beginning to get into open source and would like to contribute, yes. It is very much stable. The parser may look a bit off for a newcomer, but if you look deeper into it you will understand the logic behind it in a less-confused and more productive manner. Note And if you don't want to believe me, then let the facts speak for themselves: Salmon Lisp can run one million lines of code at the exact speed as the COMPILER OPTIMIZED SBCL. Near native overhead with high-level scripting A bunch of features packed into the tiny binary that SLisp is. If this is a language primarily for Scripting, where's cdr & car ? There's no such thing as cons or any sort of memory addresses in SLisp, instead it's a generic standard and a generic simplified approach to the Lisp & Common Lisp libraries. There's a somewhat working implementation of cdr and car in the Standard Library. But it's not what you'd expect. ( set a ( list 1 2 )) ( print ( car a )) ; 1 ( print ( cdr a )) ; 2 ( print ( + ( cdr a ) 1 )) How is SLisp \"less rigid\" than something like SBCL? While this may be a stretch, it's all in the handling. With SBCL, if you tried to print \"hello, world\", the output will literally be \"hello world\": ( print \"hello\" ) ; output: ; <whitespace> ; \"hello\" It's a bit strange, but due to the native performance SBCL gives you, it's a small tradeoff. But this is unlike SLisp, it will just print \"hello\" and do exactly what you want it to.","title":"FAQ"},{"location":"FAQ/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"FAQ/#i-see-this-doesnt-use-a-traditional-parsing-method-is-it-stable","text":"This is a common question for those beginning to get into open source and would like to contribute, yes. It is very much stable. The parser may look a bit off for a newcomer, but if you look deeper into it you will understand the logic behind it in a less-confused and more productive manner. Note And if you don't want to believe me, then let the facts speak for themselves: Salmon Lisp can run one million lines of code at the exact speed as the COMPILER OPTIMIZED SBCL. Near native overhead with high-level scripting A bunch of features packed into the tiny binary that SLisp is.","title":"I see this doesn't use a traditional parsing method, is it stable?"},{"location":"FAQ/#if-this-is-a-language-primarily-for-scripting-wheres-cdr-car","text":"There's no such thing as cons or any sort of memory addresses in SLisp, instead it's a generic standard and a generic simplified approach to the Lisp & Common Lisp libraries. There's a somewhat working implementation of cdr and car in the Standard Library. But it's not what you'd expect. ( set a ( list 1 2 )) ( print ( car a )) ; 1 ( print ( cdr a )) ; 2 ( print ( + ( cdr a ) 1 ))","title":"If this is a language primarily for Scripting, where's cdr &amp; car?"},{"location":"FAQ/#how-is-slisp-less-rigid-than-something-like-sbcl","text":"While this may be a stretch, it's all in the handling. With SBCL, if you tried to print \"hello, world\", the output will literally be \"hello world\": ( print \"hello\" ) ; output: ; <whitespace> ; \"hello\" It's a bit strange, but due to the native performance SBCL gives you, it's a small tradeoff. But this is unlike SLisp, it will just print \"hello\" and do exactly what you want it to.","title":"How is SLisp \"less rigid\" than something like SBCL?"},{"location":"SLib/","text":"The Salmon Standard Library (SSLibrary) The SLisp standard library consists of a few functions to aid in development and rapid creation of fast and powerful algorithms. You can just choose the version of SLisp you would like to view the documentation for.","title":"Index"},{"location":"SLib/#the-salmon-standard-library-sslibrary","text":"The SLisp standard library consists of a few functions to aid in development and rapid creation of fast and powerful algorithms. You can just choose the version of SLisp you would like to view the documentation for.","title":"The Salmon Standard Library (SSLibrary)"},{"location":"SLib/Iterating/","text":"Iterator Functions There are many different functions for iterating and creating many types of loops. This document will go over some of the basic use cases for them. each The each keyword iterates over the given list and uses a variable @ to notate each variable. For example, if you want to iterate a list, and add every number in it by one, you would do the following: ( each list ( print ( + @ 1 ))) This is the most basic ( and recommended ) form of list iteration. while While is the de-facto , tried and true method of iteration no matter how big or small the task! The while keyword works like it would in any other language, a clause & a body. This adds a variable until it is the number 10 . ( while ( < variable 10 ) ( set variable ( + variable 1 ))) until Note The until keyword has not been publicly released yet and is a part of the SLisp 31 release. To use it you must compile the 31 build yourself. Please see building Salmon (dead link) for tips. The until keyword runs a block of code until the clause becomes true. It's useful for creating loops and could be considered the super-standard for -loop of modern SLisp. Here's a quick example of the until loop in action: ( set a 0 ) ( until ( > a 5 ) ( set a ( + a 1 ))) Classic Danger The classic method is not as memory-safe as the other functions, and besides, they are built for this life! Use the newer, more modern functions to accomplish your iteration tasks. The classic method of iteration, that could also be defined as recursion is a method of checking a variable inside of a function and running the function again. Example: ( defun is_x_5 () ( case ( not x 5 ) ( progn ( set x ( + x 1 )) ( is_x_5 )) ( print \"Done! X is 5!\" )))","title":"Iterating"},{"location":"SLib/Iterating/#iterator-functions","text":"There are many different functions for iterating and creating many types of loops. This document will go over some of the basic use cases for them.","title":"Iterator Functions"},{"location":"SLib/Iterating/#each","text":"The each keyword iterates over the given list and uses a variable @ to notate each variable. For example, if you want to iterate a list, and add every number in it by one, you would do the following: ( each list ( print ( + @ 1 ))) This is the most basic ( and recommended ) form of list iteration.","title":"each"},{"location":"SLib/Iterating/#while","text":"While is the de-facto , tried and true method of iteration no matter how big or small the task! The while keyword works like it would in any other language, a clause & a body. This adds a variable until it is the number 10 . ( while ( < variable 10 ) ( set variable ( + variable 1 )))","title":"while"},{"location":"SLib/Iterating/#until","text":"Note The until keyword has not been publicly released yet and is a part of the SLisp 31 release. To use it you must compile the 31 build yourself. Please see building Salmon (dead link) for tips. The until keyword runs a block of code until the clause becomes true. It's useful for creating loops and could be considered the super-standard for -loop of modern SLisp. Here's a quick example of the until loop in action: ( set a 0 ) ( until ( > a 5 ) ( set a ( + a 1 )))","title":"until"},{"location":"SLib/Iterating/#classic","text":"Danger The classic method is not as memory-safe as the other functions, and besides, they are built for this life! Use the newer, more modern functions to accomplish your iteration tasks. The classic method of iteration, that could also be defined as recursion is a method of checking a variable inside of a function and running the function again. Example: ( defun is_x_5 () ( case ( not x 5 ) ( progn ( set x ( + x 1 )) ( is_x_5 )) ( print \"Done! X is 5!\" )))","title":"Classic"},{"location":"SLib/versions/1.5.0/","text":"Salmon Lisp 1.5.0 Standard Library Documentation This is the very first release of SLisp, more commonly known as Salmon. keywords | Operators | Functions","title":"Index"},{"location":"SLib/versions/1.5.0/#salmon-lisp-150-standard-library-documentation","text":"This is the very first release of SLisp, more commonly known as Salmon. keywords | Operators | Functions","title":"Salmon Lisp 1.5.0 Standard Library Documentation"},{"location":"SLib/versions/1.5.0/Functions/","text":"Salmon 1.5.0 Function Documentation println Danger Avoid using println as it does not do anything. It simply prints a message saying not to use it and then exits. Prints a like of text print [text...] Prints out the given arguments. strcat [str1] [str2] Returns a string of str1 + str2 . access [name] Returns the value of [name] .","title":"Functions"},{"location":"SLib/versions/1.5.0/Functions/#salmon-150-function-documentation","text":"","title":"Salmon 1.5.0 Function Documentation"},{"location":"SLib/versions/1.5.0/Functions/#println","text":"Danger Avoid using println as it does not do anything. It simply prints a message saying not to use it and then exits. Prints a like of text","title":"println"},{"location":"SLib/versions/1.5.0/Functions/#print-text","text":"Prints out the given arguments.","title":"print [text...]"},{"location":"SLib/versions/1.5.0/Functions/#strcat-str1-str2","text":"Returns a string of str1 + str2 .","title":"strcat [str1] [str2]"},{"location":"SLib/versions/1.5.0/Functions/#access-name","text":"Returns the value of [name] .","title":"access [name]"},{"location":"SLib/versions/1.5.0/Keywords/","text":"SLisp 1.5.0 Builtin Keywords set [name] [value] Creates a new variable called name and sets it's value to value . eq [this] [that] The english form of the operator +. list [name] [habitants..] Warning The entirety of list functionality is in very early alpha. It may not work as intended and some values may be incorrect. Sorry. Creates a new list with the arguments as the inhabitants. ( list a 1 2 3 4 ) format [list] form* Note This function would later on be replaced by the each keyword. Please keep that in mind as they do the same things. Iterates a list and runs the given code with the list object as a variable. ( format my-list ( print ( access @ ))) if [stat] true-form* Checks if stat is true, if so, it will run the true-form .","title":"Keywords"},{"location":"SLib/versions/1.5.0/Keywords/#slisp-150-builtin-keywords","text":"","title":"SLisp 1.5.0 Builtin Keywords"},{"location":"SLib/versions/1.5.0/Keywords/#set-name-value","text":"Creates a new variable called name and sets it's value to value .","title":"set [name] [value]"},{"location":"SLib/versions/1.5.0/Keywords/#eq-this-that","text":"The english form of the operator +.","title":"eq [this] [that]"},{"location":"SLib/versions/1.5.0/Keywords/#list-name-habitants","text":"Warning The entirety of list functionality is in very early alpha. It may not work as intended and some values may be incorrect. Sorry. Creates a new list with the arguments as the inhabitants. ( list a 1 2 3 4 )","title":"list [name] [habitants..]"},{"location":"SLib/versions/1.5.0/Keywords/#format-list-form","text":"Note This function would later on be replaced by the each keyword. Please keep that in mind as they do the same things. Iterates a list and runs the given code with the list object as a variable. ( format my-list ( print ( access @ )))","title":"format [list] form*"},{"location":"SLib/versions/1.5.0/Keywords/#if-stat-true-form","text":"Checks if stat is true, if so, it will run the true-form .","title":"if [stat] true-form*"},{"location":"SLib/versions/1.5.0/Operators/","text":"SLisp 1.5.0 Operators (math) + Function for addition between numbers. (math) = Basic function for checking equalities between two variables.","title":"Operators"},{"location":"SLib/versions/1.5.0/Operators/#slisp-150-operators","text":"","title":"SLisp 1.5.0 Operators"},{"location":"SLib/versions/1.5.0/Operators/#math","text":"Function for addition between numbers.","title":"(math) +"},{"location":"SLib/versions/1.5.0/Operators/#math_1","text":"Basic function for checking equalities between two variables.","title":"(math) ="},{"location":"SLib/versions/2.3/","text":"Salmon Standard Library 2222.3 Docs","title":"Index"},{"location":"SLib/versions/2.3/#salmon-standard-library-22223-docs","text":"","title":"Salmon Standard Library 2222.3 Docs"}]}